<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>UVM and Python &mdash; pyuvm v3.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=7d54114d" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=5773a0da"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="pyuvm package" href="../pyuvm.html" />
    <link rel="prev" title="Introduction" href="README.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            pyuvm
          </a>
              <div class="version">
                v3.0.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="README.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="README.html#installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="README.html#usage">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="README.html#the-pyuvm-testbench">The <strong>pyuvm</strong> testbench</a></li>
<li class="toctree-l1"><a class="reference internal" href="README.html#contributing">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="README.html#license">License</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">UVM and Python</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pythonizing-the-uvm">Pythonizing the UVM</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#static-typing-vs-duck-typing">Static Typing vs. Duck Typing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#exception-handling">Exception Handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyuvm-exceptions"><strong>pyuvm</strong> Exceptions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#coding-differences-between-systemverilog-uvm-and-pyuvm">Coding differences between SystemVerilog UVM and <strong>pyuvm</strong></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#underscore-naming">Underscore Naming</a></li>
<li class="toctree-l3"><a class="reference internal" href="#decorators-and-accessor-functions">Decorators and Accessor Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#uvm-object-wrapper-and-factories"><code class="docutils literal notranslate"><span class="pre">uvm_object_wrapper</span></code> and Factories</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-python-functionality-instead-of-uvm-functions">Using Python functionality instead of UVM functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#uvm-policy-class"><code class="docutils literal notranslate"><span class="pre">uvm_policy</span></code> Class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reporting-classes">Reporting Classes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../pyuvm.html">pyuvm package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pyuvm</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">UVM and Python</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/docsources/UVM_and_Python.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="uvm-and-python">
<h1>UVM and Python<a class="headerlink" href="#uvm-and-python" title="Link to this heading"></a></h1>
<p>The Universal Verification Methodology (UVM) grew out of the Open Verification
Methodology (OVM) which grew out of the Advanced Verification Methdology (AVM)
which leveraged the SystemVerilog programming language.</p>
<p>Though this long lineage suggests that the UVM must be implemented in
SystemVerilog, this is not the case. The UVM is a class library, and a class
library can be implemented in any object oriented programming language.</p>
<p><strong>pyuvm</strong> implements the UVM using Python.  Creating testbenches using Python
has several advantages over SystemVerilog:</p>
<blockquote>
<div><ul class="simple">
<li><p>The Python ecosystem is larger than the SystemVerilog ecosystem.  More
developers understand Python than SystemVerilog, and Python has a long tradition
of being the language of choice for large-scale object oriented projects.</p></li>
<li><p>Python is object-oriented, even more so than SystemVerilog, and so it is
easier to deliver functions such as overridable factories in Python than
SystemVerilog.</p></li>
<li><p>Python runs without a simulator, and so is faster than SystemVerilog.</p></li>
<li><p>Python forces the testbench developer to separate simulated and timed
RTL code from testbench code.  This means that testbenches written with
Python support accelerated testbenches with little, if any, modification.</p></li>
</ul>
</div></blockquote>
<p>While Python is an excellent testbench development language, the UVM is an
excellent Verification Library. Implementing the UVM using Python gives us
the best of both worlds.</p>
<section id="pythonizing-the-uvm">
<h2>Pythonizing the UVM<a class="headerlink" href="#pythonizing-the-uvm" title="Link to this heading"></a></h2>
<p>Much of the UVM specification in IEEE-1800.2-2017 is driven by elements of
the SystemVerilog programming language.  Blindly implementing all that is in
the UVM specification is not only impossible (there are no parameters in Class
declarations, for example) but also unwise.</p>
<p>Many elements of Python make it much easier to create testbench code using
Python than SystemVerilog.  For example there are no arcane issues of typing, and
Python already has common tools for logging and interprocess communication.</p>
<p>Rather than try to mimic the UVM completely, this implementation delivers the
functionality of the UVM even if this changes the details of delivering the
functionalty.  This section examines some differences that we’ll see in
this implementation.</p>
<section id="static-typing-vs-duck-typing">
<h3>Static Typing vs. Duck Typing<a class="headerlink" href="#static-typing-vs-duck-typing" title="Link to this heading"></a></h3>
<p>SystemVerilog is a statically typed language, you declare variables to be of
a certain type in the source code before using them.  It is also a relatively
weakly typed languaged (relative to VHDL).  You can declare a variable to be
a <code class="docutils literal notranslate"><span class="pre">short</span> <span class="pre">int</span></code> and another to be an <code class="docutils literal notranslate"><span class="pre">integer</span></code> and still add them with no problem.</p>
<p>Python using Duck Typing, which is form of dynamic typing.  Duck typing says
that if something looks like a duck, and acts like a duck, then we’ll consider it
a duck.  That means we don’t declare a variable to be of type <code class="docutils literal notranslate"><span class="pre">duck</span></code>, instead we
call <code class="docutils literal notranslate"><span class="pre">duck.quack()</span></code> and see if we get an exception.</p>
<p>The UVM can be difficult to write because of its static typing. A lot of energy
goes into parameterizing classes to get the behavior you want, that problem
goes away in Python.  Instead, you see runtime errors if you mess up the typing.</p>
</section>
<section id="exception-handling">
<h3>Exception Handling<a class="headerlink" href="#exception-handling" title="Link to this heading"></a></h3>
<p>Unlike SystemVerilog, Python provides the ability to raise and catch exceptions.
While a SystemVerilog programmer needs to check to be sure that an action will
work before attempting it, a Python programmer is more likely to try the action
and catch an exception if it arises.</p>
<p>Uncaught exceptions rise through the call stack and eventually cause the Python
to dump out the stack trace information and exit. Catching exceptions keeps the
program from terminating.</p>
</section>
<section id="pyuvm-exceptions">
<h3><strong>pyuvm</strong> Exceptions<a class="headerlink" href="#pyuvm-exceptions" title="Link to this heading"></a></h3>
<p>Review the documentation for the <code class="docutils literal notranslate"><span class="pre">error_classes</span></code> module to see the Exceptions defined in <strong>pyuvm</strong>.</p>
</section>
</section>
<section id="coding-differences-between-systemverilog-uvm-and-pyuvm">
<h2>Coding differences between SystemVerilog UVM and <strong>pyuvm</strong><a class="headerlink" href="#coding-differences-between-systemverilog-uvm-and-pyuvm" title="Link to this heading"></a></h2>
<p>The topics outline above lead to differences between the way <strong>pyuvm</strong> implements
behaviors vs. how SystemVerilog does it.  This section highlights these differences.</p>
<section id="underscore-naming">
<h3>Underscore Naming<a class="headerlink" href="#underscore-naming" title="Link to this heading"></a></h3>
<p>Python programs use camel casing to define classes, but <strong>pyuvm</strong> uses underscore
naming to match the IEEE specification.  <code class="docutils literal notranslate"><span class="pre">uvm_object</span></code> is named <code class="docutils literal notranslate"><span class="pre">uvm_object</span></code> not <code class="docutils literal notranslate"><span class="pre">UvmObject</span></code>.</p>
</section>
<section id="decorators-and-accessor-functions">
<h3>Decorators and Accessor Functions<a class="headerlink" href="#decorators-and-accessor-functions" title="Link to this heading"></a></h3>
<p>SystemVerilog UVM sets and gets variable values using accessor functions such
as <code class="docutils literal notranslate"><span class="pre">set_name()</span></code> and <code class="docutils literal notranslate"><span class="pre">get_name</span></code>. Python implements similar functionality using
the <code class="docutils literal notranslate"><span class="pre">&#64;property</span></code> decorator.</p>
<p>While <strong>pyuvm</strong> could have changed all the accessor functions to properties, it implements
the IEEE 1800.2 spec and keeps the accessor functions.</p>
</section>
<section id="uvm-object-wrapper-and-factories">
<h3><code class="docutils literal notranslate"><span class="pre">uvm_object_wrapper</span></code> and Factories<a class="headerlink" href="#uvm-object-wrapper-and-factories" title="Link to this heading"></a></h3>
<p>SystemVerilog has relatively poor class manipulation mechanisms.  Most of
the class information has already been determined at compile time and dynamically
creating objects of different classes, or overriding one class with another, requires
considerable gymnastics.</p>
<p>Python, on the other hand easily handles classes.  Classes are objects just like
everything else in the language.</p>
<p>As a result, <strong>pyuvm</strong> does not need the macros we use in SystemVerilog to
register classes with the factory.  It does not have <cite>uvm_object_utils</cite> or <cite>uvm_component_utils</cite>
macros.  It registers all classes that extend <code class="docutils literal notranslate"><span class="pre">uvm_void</span></code> with the factory.</p>
</section>
<section id="using-python-functionality-instead-of-uvm-functions">
<h3>Using Python functionality instead of UVM functions<a class="headerlink" href="#using-python-functionality-instead-of-uvm-functions" title="Link to this heading"></a></h3>
<p>The UVM defines methods that make up for SystemVerilog’s relative
immaturity relative to Python.  For example <code class="docutils literal notranslate"><span class="pre">uvm_object</span></code> defines
a <cite>get_type()</cite> method to get the type of an object.  Python has a <code class="docutils literal notranslate"><span class="pre">type()</span></code>
function that does the same thing for all objects.</p>
<p>Therefore, <strong>pyuvm</strong> raises <code class="docutils literal notranslate"><span class="pre">UsePythonMethod</span></code> if you call <code class="docutils literal notranslate"><span class="pre">get_type()</span></code>.</p>
</section>
<section id="uvm-policy-class">
<h3><code class="docutils literal notranslate"><span class="pre">uvm_policy</span></code> Class<a class="headerlink" href="#uvm-policy-class" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">uvm_policy</span></code> Classes provide functionality that is built into
Python with the <code class="docutils literal notranslate"><span class="pre">setattr</span></code> and <code class="docutils literal notranslate"><span class="pre">getattr</span></code> methods.</p>
<p>There are no field macros and thus no need to implement this class.</p>
</section>
<section id="reporting-classes">
<h3>Reporting Classes<a class="headerlink" href="#reporting-classes" title="Link to this heading"></a></h3>
<p>We use Python logging instead of the UVM reporting system.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="README.html" class="btn btn-neutral float-left" title="Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../pyuvm.html" class="btn btn-neutral float-right" title="pyuvm package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Ray Salemi.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>